(**

F# Data Frameデザインノート
===========================

これはF# Data Frameライブラリの最初のバージョンで、
我々はどうすればデザインを向上させることができるか、
積極的に追求している最中です。
議論にうってつけの場所としては、
[GitHub上のissueリスト](https://github.com/BlueMountainCapital/Deedle/issues)
か、
[F# for Data and Machine Learning](http://fsharp.org/technical-groups/)
のメーリングリストのいずれかです(後者はより広範なトピックを対象にしています)。

現行のライブラリではほとんどの基礎的な機能が実装されていますが、
追加の(便利な)機能を簡単に実装することができるよう、
適切な内部「コア」機能も用意してあるつもりです。

ライブラリの実装時には、幅広い場面で有用な関数において使用されるような
**素朴(primitive)** かつ **基本的(fundamental)** な関数を少数用意するという
方針を採用しています(これらの関数は一般的には基本的なオブジェクトのメンバーとして
定義されます)。
また、一般的な操作を行う拡張メンバーや関数を
さらに増やしていけるといいと考えていますので、
是非このライブラリに貢献をお願いします！

## ライブラリの原則

 * **F# と C# で使いやすいこと** - このライブラリはF#とC#の両方で
   使用できるようにしたいと考えています。
   そのため、ほとんどの機能は拡張メンバーおよび
   (`Frame` および `Series`)モジュール関数として定義されます
   (拡張メンバーにはC#の`Extension`属性が指定されているため、
    それらはC#およびF# 3.1においてのみ利用可能です)。
   1つ異なる点として、拡張メンバーでは `KeyValuePair<K, V>` や `OptionalValue<T>`
   (ライブラリ内で定義されているC#フレンドリーな`struct`)が使用されているのに対して、
   関数ではタプルやF#の`option<T>`、省略型などが使用されています。

 * **行と列の対称性** - データフレーム内のデータは列のリストとして格納されるため、
   列方向にデータフレームを処理するほうがよいでしょう
   (列ベースのフレームを処理する関数も多数用意されています)。
   しかし`Frame<'TRowKey, `TColKey>` 型のデータには対称性が有り、
   列(シリーズ)と行の両方でアクセスできるような独自のインデックスを使用できます。
   また、`df.Columns` や `df.Rows` 経由で(ネストされた)シリーズのシリーズとして
   行や列にアクセスすることもできます。
   列キーは一般的には文字列(シリーズ名)になりますが、これは必須ではなく、
   `df.Transpose()` メソッドを呼ぶことにより、フレームを転置させることもできます。

 * **値無しおよびNaN** - データフレームには常に値無しが含まれうるものだと
   想定しているため、値無しを含む可能性のあるフレームまたはシリーズと、
   値無しを含まないものは、いずれも同じ型になっています。
   フレームやシリーズに対して実行可能な操作においては、
   値無しを適切に処理できるように設計されています。
   これらの操作では、値をキーによって明示的に読み取ろうとしない限り、
   基本的には値無しをスキップするようになっています。
   
   現在のバージョンでは、(数値に対する)`Double.NaN`や
   (`Nullable</T>`や参照型に対する)`null`といった特定の値が「値無し」と
   みなされるようになっています。
   つまり`Double.NaN`を含むシリーズを作成したとすると、
   この値が**値無し**となり、`Series.sum`のような集計関数を呼び出すと
   値が無視されるというわけです
   (`NaN`と**値無し**の両方に対応できるようにするべきかもしれませんが、
   何が最善の選択肢なのかという問いに対する答えは出ていません)。

 * **不変性(Immutability)** - シリーズは完全に不変なデータ型ですが、
   データフレームは限定的に可変性をサポートします。
   たとえば新しいシリーズを追加、削除、置換したりすることができます
   (ただしシリーズそのものを変更することは出来ません)。
   また、データフレームの行インデックスはほぼ不変ですが、
   空のデータフレームを作成した後に最初のシリーズを追加する場合に限って
   変更されることがあります。
   
   これらの処理は `?<-` 演算子で手軽に行うことが出来るため、
   リサーチ用のスクリプトを作成している場合などに再バインドする必要もありません。

## ライブラリの内部について

以下の型は(たいていの場合には)ユーザーが直接使用するようなものではありませんが、
あまり頻繁には変更されることがない「最小限の」コアを表すものです。
ライブラリを拡張させる場合にはこれらの型を使用することになるでしょう：

 * `IVector<'TValue>` は`Address`型を経由してアクセスすることができる
   `'TValue`型の値を含んだベクターです。
   具体的な実装としては単に`int`型のアドレスを持った配列とすればいいのですが、
   ライブラリではこれを抽象化しています。
   たとえば巨大なデータセットや、ストリームからデータを読み込むような遅延ベクター、
   (Cassandra等をデータソースとするような)仮想ベクターに対しては
   `int64`をインデックスとするような配列の配列が使用されることがあります。

   ベクターには、値無しを処理するという重要な役割があります。
   そのため、整数のベクターは `array<option<int>>` とみなすことができます
   (ただしこれが連続したメモリブロックに配置されるよう、独自の値型を定義しています)。
   値無しの処理はデータフレームにとって重要な項目であると判断したため、
   オプション値やNull許容の値を格納するのではなく、
   直接サポートするべきだということになりました。
   ライブラリの実装では、単純な最適化が行われています。
   もし値無しが全くない場合は単に`array<int>`が格納されます。

 * `VectorConstruction` は判別共用体で、ベクターの構造を表すものです。
   すべてのベクター型に対して、
   ベクターを生成する方法を定義している`IVectorBuilder`という
   インターフェイスの実装が用意されます
   (このインターフェイスには要素の再シャッフルやベクターの追加、部分区間の取得なども
    定義されています)。

 * `IIndex<'TKey>` はインデックス、つまりシリーズあるいはデータフレームのキーと
   ベクター内のアドレスとのマッピングを表します。
   単純なケースでは、これは指定された特定のキー(たとえば`string`や`DateTime`)に対応する、
   配列内の`int`型オフセットを返すような単なるハッシュテーブルになります。
   きわめて単純なインデックスとしては、アイデンティティ関数(未実装です！)によって
   `int`オフセットと`int`アドレスをマッピングするだけのものになります。
   シリーズやデータフレームの場合、これは単なるレコードのリストです。

現在、以下の型が直接使用されています：

 * `Series<'TKey, 'TValue>` は`'TKey`でインデックスされた
   `'TValue`型の値のシリーズを表します。シリーズは抽象ベクター、
   インデックス、ベクタービルダーを使用するため、
   任意のデータ表現をサポートできるようになっています。
   シリーズはスライシング操作や射影、フィルタリングなど、
   いくつかの標準的な操作をサポートします。
   `Series`モジュールには他にも、いくつかの二項演算
   (スカラー倍やシリーズの加算など)やその他の操作が用意されています。

 * `Frame<'TRowKey, 'TColumnKey>` は`TRowKey`でインデックスされた行
   (これは`DateTime`あるいは`int`のような単なる序数になります)、および
   `TColumnKey`でインデックスされた列(一般的には`string`)を持った
   データフレームを表します。
   フレーム内には異種データが混在するため、データへのアクセスは動的に
   行われます。
   しかしたとえば型付のシリーズを取得するといったことも可能です。
   
   データフレームに対する操作としては、
   シリーズの追加や削除(新しいシリーズは行インデックスに従って
   アラインされます)の他に、連結(これもやはりアラインされます)も可能です。
   また、すべての行を一連の(列)シリーズとして取得したり、
   すべての列を一連の(行)シリーズとして取得することもできます。
   これらの操作は拡張メソッドとして `Frame` モジュール内で定義されています。

## 議論および問題の提起

我々としては今のところ内部の設計はリーズナブルだと思っていますが、
エンドユーザー用APIには一部の有用な機能がまだ不足しているかもしれません
(必要な機能があれば是非教えてください！)。
これまでにやりとりされた議論、並びに検討中の課題については以下の通りです：

 * **時系列データ vs. ピボットテーブル** - ライブラリには用途の異なる2つの
   データ表現があります。
   1つは(株価のような)時系列データで、一般的には行インデックスを日付として
   動作するものです。
   さらに一般的にいえば、これは **連続的** インデックスとみなすことができます。
   したがって補間や観測値のソート、データのアライメント、リスケールといった
   操作が有効です(なお**連続的**であることは**順序付**であることよりも強力です。
   時間以外では、距離に異存するシリーズだけが連続的に
   計測可能だとみなせます)。
   
   もう1つは**不連続な**観測値に対して使用します
   (たとえば顧客データを表すレコードのリストや、異なる株価のリストなどです)。
   この場合には「ピボットテーブル」の機能が必要になります。
   
   これら2つの用途はかなり異なるものですが、我々は両者を
   (単にインデックスが異なるだけの)同じ型として扱うほうがいいと判断しました。
   そうすると今度はAPIがさらに複雑になるかもしれないという問題があります。
   これらを型の中で区別しておけば、F# 3.1の拡張メソッド機能を使用して単なる
   「不連続データフレーム」あるいは「連続データフレーム」を拡張できます。
   しかし今のところすべての関数は `Frame`/`Series` モジュールに定義されており、
   任意の型を拡張する拡張メソッドが用意されています。

 * **型プロバイダー** - 我々はさらなる安全性を得るためにも、
   型プロバイダーを使用することを検討しています
   (たとえば列名のチェックやデータフレーム内の型チェックなど)。
   今のところはTODOリストに入れられているだけです。
   限定的ではあるにしても、何か便利なことが出来るのではないかと考えています。
   
   現在のアイディアとして、動的データフレームを使用してリサーチや
   プロトタイプ実装を行いたいけれども、その後にもっと具体的なデータを
   使用することになるような場合に、`DataFrame<"Open:float,Close:float">(dynamicDf)`
   というように記述することで新しく型付データフレームが
   取得できるだろうというような感じです。

上記のトピックに関して何かコメントがあれば、
是非 [GitHub上でIssuesを登録](https://github.com/BlueMountainCapital/Deedle/issues)したり、
もっと積極的に貢献したいという場合には
[F# for Data and Machine Learning](http://fsharp.org/technical-groups/)
ワーキンググループへ参加してください。
*)
