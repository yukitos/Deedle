(*** hide ***)
#load "../../../bin/Deedle.fsx"
open System

(**
遅延ロードされるシリーズを作成する
==================================

データを(たとえばデータベースなどの)外部データソースからロードする場合、
データソースを表す**実際の**時系列データを作成したいものの、
実際に必要になるまではロードさせたくないことがあります。
たとえば値を使用する前に何らかの(スライシングのような)範囲制限を行うのであれば、
データセット全体をメモリ上にロードする必要はありません。

F# data frame libraryは遅延ロードを `DelayedSeries.Create` メソッドとして
サポートしています。
このメソッドは普通の `Series<K, V>` 型のシリーズを返しますが、
内部表現が遅延評価されるという違いがあります。

## 遅延シリーズの作成

このチュートリアルでは実際のデータベースを使用しませんが、
以下のような特定の期間のデータをロードするような関数が既にあるものとします：
*)
open Deedle

/// 特定の期間に対して、日毎(午前12:00毎)にランダムな値を生成します。
/// 1番目の日付の日から始まり、(指定された期間が範囲に収まるように)
/// 2番目の日付の翌日までが範囲になります。
let generate (low:DateTime) (high:DateTime) =
  let rnd = Random()
  let days = int (high.Date - low.Date).TotalDays + 1
  seq { for d in 0 .. days -> 
          KeyValue.Create(low.Date.AddDays(float d), rnd.Next()) }

(**
ソースを乱数で生成してしまうと、シリーズの部分区間が必要になるたびに
異なる値が取得できてしまうため、本来は正しいものではありません。
ただし今回のデモとしてはこれで十分でしょう。

さて、遅延的にロードされるシリーズを作成するためには、
まず `Indices` 名前空間をオープンし、
シリーズの最小値および最大値を決め、
`DelayedSeries.Create` を呼び出します：

*)
open Deedle.Indices

// シリーズからロードできる最小値および最大値
let min, max = DateTime(2010, 1, 1), DateTime(2013, 1, 1)

// 特定の期間に対する遅延シリーズを作成
let ls = DelayedSeries.Create(min, max, fun (lo, lob) (hi, hib) -> async { 
    printfn "Query: %A - %A" (lo, lob) (hi, hib)
    return generate lo hi })

(**
挙動をわかりやすくするために、リクエストがあるたびに
要求された期間を表示するようにしています。
ただし、このコードを実行するだけでは何も表示されません。
`DelayedSeries.Create` の引数には4つの引数をとる関数を指定します：

  - `lo` および `hi` は範囲の下限および上限を表します。
    これらの型はキーの型です(たとえば今回の例であれば`DateTime`)
  - `lob` および `hib` は `BoundaryBehavior` 型の値で、
    `Inclusive` または `Exclusive` のいずれかを指定します。
    端点を範囲に含むかどうかを指定します。

サンプルの関数では端点を正しく処理しておらず、
常に端点(およびさらに多くの値)が範囲内に含まれるようになっています。
遅延ローダーはこれらの値を自動的にスキップするため、
このこと自体は問題ではありません。
しかし必要に応じて `lob` や `hib` 引数を指定し、
より最適化されたSQLクエリを組み立てることもできるでしょう。

## 未評価のシリーズを使用する

では未評価のシリーズに対して操作を行うとどうなるのか見ていきましょう。
シリーズの値やキーに実際にアクセスする操作
(たとえば `Series.observations` や、特定のキーに対するルックアップなど)を行うと、
シリーズが強制的に評価されます。

しかしデータにアクセスする前に、期間を制限してしまうことも出来ます：
*)
// 2012年1月を表すデータを取得
let jan12 = ls.[DateTime(2012, 1, 1) .. DateTime(2012, 2, 1)]

// さらなる制限として、月の前半のみに制限
let janHalf = jan12.[.. DateTime(2012, 1, 15)]

// 特定の日付の値を取得
janHalf.[DateTime(2012, 1, 1)]
// [fsi: Query: (1/1/2012, Inclusive) - (1/15/2012, Inclusive)]
// [fsi: val it : int = 1127670994]

janHalf.[DateTime(2012, 1, 2)]
// [fsi: val it : int = 560920727]
(**
9行目の出力からもわかるように、
元のシリーズに対して制限を加えてあるために、
15日分のシリーズデータしか取得されていません。
特定の範囲内にある別の値をリクエストすると、
既にデータが利用可能になっているため、即座に値が返されます。
なお `janHalf` には15日分しかデータがないため、
範囲外の値にアクセスすることはできないことに注意してください。
また、1つの値にアクセスする場合でもシリーズ全体がロードされている点にも
注意してください。
おそらく複数の値にアクセスする必要があるはずなので、
シリーズ全体をロードしてしまったほうがコストが低くなるだろう
というのがその理由です。

未評価のシリーズに対して行えるもう1つの操作として、
既存のキー範囲を持ったデータフレームにシリーズを追加することができます：
*)

// 2011年12月の日付を含んだ空のデータフレームを作成
let dec11 = Frame.ofRowKeys [ for d in 1 .. 31 -> DateTime(2011, 12, d) ]

// シリーズを'Values'列としてデータフレームに追加
dec11?Values <- ls
// [fsi: Query: (12/1/2011, Inclusive) - (12/31/2011, Inclusive)]

(**
遅延シリーズをデータフレームに追加すると、
(値が適切にアラインされるように)その時点でシリーズが評価されますが、
まずはデータフレームの範囲によって制限されます。
上のコードの場合、1ヶ月分のデータだけがロードされます。

*)
